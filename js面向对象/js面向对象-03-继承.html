<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<h1>继承</h1>
		<script>
		/*function Animal(){
			this.species = "动物";
		}
		
		function Cat(name,color){
			Animal.apply(this,arguments);
			this.name = name;
			this.color = color;
		}
		
		
		var c1 = new Cat("大毛","yellow");
		console.log(c1 instanceof Animal);*/
		
/*		function Animal(){
			this.species = "动物";
		}
		Animal.prototype.skin="有";
		
		function Cat(name,color){
			
			this.name = name;
			this.color = color;
		}
		
		
		Cat.prototype = new Animal();
		Cat.prototype.constructor=Cat;		
		var c1 = new Cat("大毛","yellow");
//		console.log(c1.constructor);		
		alert(c1.species);
		alert(c1.skin);*/
	function Animal(){}	
	Animal.prototype.skin="有";
	Animal.prototype.species = "动物";
	
	
	function Cat(name,color){
			
			this.name = name;
			this.color = color;
		}
/*	function extendC (child,parent){
		var f =function (){};
		f.prototype = parent.prototype;
　　　　 child.prototype = new f();
　　　　 child.prototype.constructor = child;
　　　　 child.uber = parent.prototype;
	}
	extendC(Cat,Animal);
  var c1=new Cat("大黄","yellow");*/
  //(拿不到构造函数里面的属性和方法)
  
    function  extend2(child,parent){
    	var c=child.prototype;
    	var p=parent.prototype;
    	for(var k in p){
    		c[k]=p[k];
    	}
    	c.uber = p;
    }
    extend2(Cat,Animal)
     var c1=new Cat("大黄","yellow");
     alert(c1.skin);

		// 继承1 在子类 执行以下父类的方法 并把this 传进去（instanceof 不明）
		// 继承2 在子类的prototype=new 父类 （子类constructor 会改变会重新指向 ）
		// Cat.prototype = new Animal();
		// Cat.prototype.constructor=Cat;
		// 继承3 Cat.prototype = Animal.prototype(不能够继承构造函数的属性/方法)
		// 继承4 用空对象做继承
		// 继承5 拷贝
			
			
		
		
			
		</script>
	</body>
</html>
