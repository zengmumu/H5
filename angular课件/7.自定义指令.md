# 指令
可以利用指令来扩展HTML标签，增加声明式语法来实现想做的任何事，可以对应用有特殊意义的元素和属性来替换一般的HTML标签

angular也内置了非常多的指令，ng-app、ng-controller

    1，浏览器得到 HTML 字符串内容，解析得到 DOM 结构。
    2，ng 引入，把 DOM 结构扔给 $compile 函数处理：
    3，找出 DOM 结构中有变量占位符
    4，匹配找出 DOM 中包含的所有指令引用
    5，把指令关联到 DOM
    6，关联到5 DOM 的多个指令按权重排列
    7，执行指令中的 compile 函数（改变 DOM 结构，返回 link 函数）
    8，得到的所有 link 函数组成一个列表作为 $compile 函数的返回
    执行 link 函数（连接模板的 scope）。
    
---
自定义指令

## resrict
    字母	风格	示例
    E	元素	<my-dir></my-dir>
    C	样式类	<span class="my-dir: exp;"></span>
    A	属性	<span my-dir="exp"></span>
    M	注释	<!-- directive: my-dir exp -->
## template&&templateUrl

template:模板内容，这个内容会根据 replace 参数的设置替换节点或只替换节点内容。
## transclude
transclude:指令元素中的原来的子节点移动到一个新模版内部
当为true时，指令会删掉原来的内容，使你的模版可以用ng-transclude指令进行重新插入
```js
.directive ("customTags",function(){
		return {
			restrict:'ECAM'，
			template：‘<div>new数据<span ng-transclude></span></div>’,
			replace:true,
		        transclude:true
		}
})
```
transclude:指令元素中的原来的子节点移动到一个新模版内部
当为true时，指令会删掉原来的内容，使你的模版可以用ng-transclude指令进行重新插入

## replace
replace:如果此配置为true则替换指令所在的元素，如果为false或者不指定，则把当前指令追加到所在的元素内部
对于restrict为元素(E)在最终效果中是多余的，所有 replace通常设置为true

## 指令编译


1. 标准浏览器API转化将html转化成dom，所以自定义的html标签必须符合html的格式

2. Angular compile
	搜索匹配directive，按照priority排序，并执行directive上的compile方法

3. Angular link
	执行directive上的link方法，进行scope绑定及事件绑定

## compile
complie函数用来对模版自身进行转换，仅仅在编译阶段运行一次

complie中直接返回的函数是postLink，表示link参数需要执行的函数，也可以返回一个对象里面包含preLink和postLink

当定义complie参数时，将无视link参数，因为complie里返回的就是该指令需要执行的link函数
```js
compile:function(elem,attrs){
    console.log("指令编译前");
    elem.append("<span>我是在编译前添加的内容</span>");
    /*return{
    	pre:function(scope,elem,attrs,contrl){
    		console.log("指令开始编译");
    			
    		
    	},
    	post:function(scope,elem,attrs,contrl){
    		
    		console.log("指令开始编译结束");
    	},
    }//return ed*/
    return function(scope,elem,attrs,contrl){
    	console.log("我就是link")
        }
    }
```

## link 
link函数负责在模型和视图之间进行动态关联，对于每个指令的每个实例，link函数都会执行一次
link compile 区别
1. 一般只用 link
2. compile 作用是对指令转换
3. link 模型和视图建立关联，包括在元素上注册事件
4. scope 再link链接阶段才会被绑定到元素上
5. 多个实例 compile 执行一次 link 执行多次
```js
link:function(scope,elem,attrs,ctrl){
	console.log("link");
}

```
## controller
controller 他会暴露一个API，利用这个API可以在多个指令之间通过依赖注入进行通信
controller($scope,$element,$attrs,$transclude)
## controllerAs
controllerAs 是给controller起个别名，方便使用
## require 
可以将其他指令传递给自己

directiveName	  通过驼峰法的命名指定了控制器应该带有哪一条指令,  
^directiveName 	在父级查找指令  
?directiveName	   表示指令是可选的，如果找不到，不需要抛出异常  


html
```
<body ng-controller="mainCtrl">
		<div class="container">
			<my-tag></my-tag>
			<my-tag></my-tag>
		</div>
	</body>
```
js
```
angular.module("myapp",[])
.controller("mainCtrl",function($scope){

})
.directive("myTag",function(){
	return{
		restrict:"ECMA",
		template:'<div><p ng-repeat="x in data track by $index"> {{x}}</p><p><my-btn></my-btn></p></div>',
		
		link:function(scope,elem,attrs,ctrl){
			console.log("link");
		},
		controller:function($scope){
			//alert("我是alert");
			$scope.data=["numu","zql","caicai","大黄"];
			console.log("controller");
			this.addData=function(s){
				$scope.$apply(function(){
					$scope.data.push(s);	
				})
			}
		},
		 controllerAs:"linkCtrl",
		
		
	}
})
.directive("myBtn",function(){
	return {
		restrict:"ECMA",
		template:'<div><input type="text" ng-model="msg"><button class="btn">添加</button></div>',
		replace:true,
		require:"^myTag",
		
		link:function(scope,elem,attrs,ctrl){
			
	/*	elem.find("button").on("click",function(){
				ctrl.addData(scope.msg)
			})*/
			$(elem).find(".btn").on("click",function(){
				ctrl.addData(scope.msg);
			})
		}
	}
})
		
```

## scope
为当前指令创建一个新的作用域，而不是使之继承父作用域

false 继承父元素的作用域
true 创建一个新的作用域object 独立的scope
object:参数
&:作用域把父作用域的属性包装成一个函数，从而以函数的方式读写父作用域的属性
=:作用域的属性与父作用域的属性进行双向绑定，任何一方的修改均影响到对方
@:只能读取父作用域里的值单项绑定
```
a:'=data1'
=作用域的属性与父作用域的属性进行双向绑定，任何一方的修改均影响到对方
<cus-tom data1="data2">

b:'@data2'
@:只能读取父作用域里的值单项绑定
<cus-tom data2="{{data2}}">

c:'&data3'
&:作用域把父作用域的属性包装成一个函数，从而以函数的方式读写父作用域的属性
<cus-tom data3="data3">
{{b()}}
```

```
<book-list parent-title="{{title}}" parent-books="books"></book-list>
 <div book-list books="books" parent-books="books" parent-title="{{title}}">
scope:true,
scope:{}
 scope:{
        // 将父元素books封装成一个a函数
        // a:'&books'
        // 双向绑定 b = parentBooks属性对应的父作用域的表达式
        // b:'=parentBooks'

        // 使用简单数据类型的方法
        c:'@parentTitle',
        // b:'=parentBooks',
        a:'&parentBooks'
            },
```